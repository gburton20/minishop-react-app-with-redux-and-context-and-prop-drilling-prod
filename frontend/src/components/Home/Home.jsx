import { useContext, useEffect, useState } from 'react'
import ProductFilter from './ProductFilter'
import SellProductForm from './SellProductForm'
import BannerAdContainer from './BannerAdContainer'
import ProductCardsList from './ProductCardsList/ProductCardsList'
import SellProductButton from './SellProductButton'
import { useAuth0 } from "@auth0/auth0-react";
import CartContext from '../../context/CartContext'
// New Redux imports:
import { useSelector, useDispatch } from 'react-redux';
import { fetchProducts, setSelectedCategory, setProducts } from '../../features/productsFiltersSlice';


const Home = ({
  handleAddToCart = useContext(CartContext)}) => {

  // STATE SECTION:

  // Redux - 1 - A for refactoring:
  // const [products, setProducts] = useState([]);

  // Redux - 1 - B for refactoring:
  // const [selectedCategory, setSelectedCategory] = useState('All')

  // State for the open and closing of the selling product modal form:
  const [isFormOpen, setIsFormOpen] = useState(false);

  // State for the handling of user-generated product data generated by the submission of the SellProductForm.jsx
  const [customProducts, setCustomProducts] = useState([]);

  // END OF STATE SECTION

  // START of Redux section:
  // A shorthand for accessing useDispatch()'s WRITE functionality of data from functional components to the store object:
  const dispatch = useDispatch();

  // The section for useSelector() hook, the READ functionality of data from the store object by functional components:
  // 'Redux versions' of the prior state variables:
  const products = useSelector((state) => state.productsFilters.products);
  const selectedCategory = useSelector((state) => state.productsFilters.selectedCategory);

  // 'Redux versions' of the prior set state variable functions:
  const setProductsLocal = (newProducts) => {
    dispatch(setProducts(newProducts));
  };
  const setSelectedCategoryLocal = (category) => {
    dispatch(setSelectedCategory(category))
  }

  const status = useSelector((state) => state.productsFilters.status);
  const error = useSelector((state) => state.productsFilters.error);

  // The section for useSDispatch() hook, the WRITE functionality of data from functional components to the store object:
  useEffect(() => {
    if (status === 'idle') {
      dispatch(fetchProducts());
    }
  }, [dispatch, status]);

  const handleCategoryChange = (category) => {
    dispatch(setSelectedCategory(category));
  };

  // END of Redux section

  // AUTH0 SECTION

  // Extract the isAuthenticated property from the object returned by the useAuth0() hook via object destructuring:
  const { isAuthenticated } = useAuth0();
  
  // END OF AUTH0 SECTION

  
  // START OF LOGIC SECTION FOR SELLPRODUCTFORM.JSX:
  
  // Functions for revealing the selling product form:
  // Opening the form - update the isFormOpen state to true
  const openForm = () => setIsFormOpen(true);
  // Closing the form - update the isFormOpen state to false
  const closeForm = () => setIsFormOpen(false);
  
  // handleAddProduct is the event handler for adding a new product.
  // newProduct is the product object submitted by the user when they submit their product form.
  // This function uses the spread operator (...) to create a new array with the existing products and the new product at the end.
  // Calls setProducts to update the state without mutating the original products array.
  const handleAddProduct = (newProduct) => {
    // Create a copy of the newProduct object, and add an id field to it.
    const newProductWithId = {
      // Use the spread operator to make a copy of the newProduct object:
      ...newProduct,
      // Set an arbitrary id for each new product created by the form via JS randomising conventions:
      id: Date.now() + Math.random()
    };
    // Update the products state with a shallow copy of the previous version of the products state with newProductWithId input at the end 
    setProductsLocal([...products, newProductWithId]);
  }
  
  // END OF LOGIC SECTION FOR SELLPRODUCTFORM.JSX
  
  // START OF LOGIC SECTION FOR FETCHING PRODUCTS
  // Fetch third-party products
  useEffect(() => {
    const fetchThirdPartyProducts = async () => {
      const response = await fetch('https://api.escuelajs.co/api/v1/products');
      const fetchedProducts = await response.json();
      setProductsLocal(fetchedProducts);
    };
    fetchThirdPartyProducts();
  }, []);
  
  // Fetch user-generated products from Django backend
  useEffect(() => {
    const fetchCustomProducts = async () => {
      try {
        const response = await fetch('http://localhost:8000/products/');
        if (response.ok) {
          const data = await response.json();
          setCustomProducts(data.results || data); // handle paginated or non-paginated response
        }
      } catch (err) {
        console.error('Error fetching custom products:', err);
      }
    };
    fetchCustomProducts();
  }, []);
  // END OF LOGIC SECTION FOR FETCHING PRODUCTS
  
  // START OF LOGIC SECTION FOR THE COMBINATION OF 3RD-PARTY AND USER-GENERATED PRODUCTS
  
  
  // Combine both sources
  const allProducts = [
    ...products.map(product => ({
      category: product.category ? product.category.name : null,
      id: product.id,
      image: product.images && product.images.length > 0 ? product.images[0] : '',
      name: product.title,
      price: product.price
    })),
    ...customProducts.map(product => ({
      category: product.category,
      id: product.id ? `custom-${product.id}` : `custom-fallback-${product.idx}`,
      image: product.image
      ? `http://localhost:8000${product.image}`
      : '',      
      name: product.name,
      price: product.price
    }))
  ];  
  // END OF LOGIC SECTION FOR THE COMBINATION OF 3RD-PARTY AND USER-GENERATED PRODUCTS
  
  // START OF LOGIC SECTION FOR PRODUCTFILTER.JSX

  // Turned OFF this instance of the handleCategoryChange for Redux refactoring:
  // A handler function to handle the updating of the selected category:
  // For the selected categoryName (the type of product), update the selectedCategory state with the value of the categoryName via the setSelectedCategory set state variable function:
  // const handleCategoryChange = (categoryName) => {
  //   setSelectedCategory(categoryName)
  // }

  // Filter the list of products based on the category the user selected:
  // If the selectedCategory, a state variable, is 'All'
  const filteredProducts = selectedCategory === 'All'
  // Return all products:
    ? allProducts 
  // Else, return only products whose category (product.category) matches the value of selectedCategory (whose value has been updated when the user clicks a filter button in ProductFilter.jsx). 
  : allProducts.filter(product => {
      console.log('Comparing:', product.category, selectedCategory);
      return product.category === selectedCategory;
    });

  // END OF LOGIC SECTION FOR PRODUCTFILTER.JSX
  return (
    <div className='home'>
      <ProductFilter
        // Pass the handleCategoryChange() function to the ProductFilter.jsx component:
        onCategoryChange={handleCategoryChange}
      />
      {/* {isAuthenticated ? (
        <SellProductForm/>
      )} */}
      {/* If the user is authenticated, show the SellProductButton */}
        {isAuthenticated && <SellProductButton onClick={openForm}/>}
        {isFormOpen && <SellProductForm 
          handleAddProduct={handleAddProduct}
          closeForm={closeForm} 
          isFormOpen={isFormOpen}
          setCustomProducts={setCustomProducts}
        />}
        <BannerAdContainer/>
        {/* {console.log('Price-only rendering issue, 2nd debug log, products', products)} */}
        <ProductCardsList
          // Pass the filteredProducts variable, an array of objects, to ProductCardsList for rendering:
          products={filteredProducts}
          // Pass the allProducts variable, the combination of 3rd-party products 
          // allProducts={allProducts}
          // Continue to pass handleAddToCart and itemInCartCount on from App.jsx to child components:
          handleAddToCart={handleAddToCart}
        />
      {/* Only to be used to test the inclusion of the user_metadata key of the user object in the Auth0 dashboard, and its successful passing into this SPA: */}
      {/* <div>Theme: {metadata?.theme ?? "not set"}</div> */}
    </div>
  )
}

export default Home